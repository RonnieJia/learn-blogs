(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{418:function(s,t,e){"use strict";e.r(t);var a=e(2),n=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),t("p",[s._v("Apple在2015年的WWDC提出Swift是一种面向协议编程（Protocol Oriented Programming，简称POP）的语言，在Swift的源码中我们可以看到大量的协议。本文主要目的是带领大家简单认识面向协议编程。")]),s._v(" "),t("p",[s._v("本文主要从以下这几点来简单介绍：")]),s._v(" "),t("ol",[t("li",[s._v("Swift中的协议")]),s._v(" "),t("li",[s._v("为什么面向协议")]),s._v(" "),t("li",[s._v("协议扩展的一些注意点")])]),s._v(" "),t("h3",{attrs:{id:"_1-swift中的协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-swift中的协议"}},[s._v("#")]),s._v(" 1. Swift中的协议")]),s._v(" "),t("p",[s._v("Swift 标准库中有 50 多个复杂不一的协议，几乎所有的实际类型都是满足若干协议的。protocol 是 Swift 语言的基础，语言的其他部分正是在这个基础上组织和建立起来的。这和我们熟知的面向对象的构建方式很不一样。")]),s._v(" "),t("p",[s._v("一个简单的Swift协议可以如下定义：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("protocol Eatable {\n    var isHunger: Bool { get }\n    func eatFoods()\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])]),t("p",[s._v("可以看到Swift协议就是一组属性或方法的定义，而如果某个具体类型想要遵守一个协议，那它需要实现这个协议所定义的所有这些内容。协议实际上做的事情不过是“关于实现的约定”。")]),s._v(" "),t("h3",{attrs:{id:"_2-为什么面向协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-为什么面向协议"}},[s._v("#")]),s._v(" 2. 为什么面向协议")]),s._v(" "),t("p",[s._v("Swift和OC一样都是面向对象（OOP）的语言，同OC一样使用OOP编写代码能满足我们所有需求的开发。那为什么还需要引入POP呢？")]),s._v(" "),t("p",[s._v("OOP是一种很好的抽象方式，但有些场景还存在一些缺陷。它无法为两个不同继承关系的类添加同一个方法。例如有个"),t("code",[s._v("CustomeLabel")]),s._v("和"),t("code",[s._v("CustomButton")]),s._v("分别继承与"),t("code",[s._v("UILabel")]),s._v("和"),t("code",[s._v("UIButton")]),s._v("，现在需要给这两个自定义的控件添加同一个方法"),t("code",[s._v("func method()")]),s._v("，OOP我们可能会使用以下几种方案：")]),s._v(" "),t("ol",[t("li",[s._v("同样的代码分别写到"),t("code",[s._v("CustomeLabel")]),s._v("和"),t("code",[s._v("CustomButton")]),s._v("中。这种方案不建议采用，应该尽量避免这种做法。")]),s._v(" "),t("li",[s._v("生成一个单独的类实现这个"),t("code",[s._v("func method()")]),s._v("方法，然后"),t("code",[s._v("CustomeLabel")]),s._v("和"),t("code",[s._v("CustomButton")]),s._v("引入这个类。这种方案引入了额外的依赖。")]),s._v(" "),t("li",[s._v("将"),t("code",[s._v("func method()")]),s._v("这个方法添加到共同的父类"),t("code",[s._v("UIView")]),s._v("中。这种方案会给"),t("code",[s._v("UIView")]),s._v("添加更多更多的功能代码导致分工不明确，并且"),t("code",[s._v("UIView")]),s._v("的一些其他子类并不需要这个方法。")])]),s._v(" "),t("p",[s._v("使用POP解决上述问题，首先我们需要定义一个协议：")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("protocol Customable {\n    func method()\n}\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("然后"),t("code",[s._v("CustomLabel")]),s._v("和"),t("code",[s._v("CustomButton")]),s._v("同时遵守这个协议，并实现"),t("code",[s._v("func method()")]),s._v("方法")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('class CustomLabel: UILabel, Customable {\n    func method() {\n        print("This is customMethod")\n    }\n}\n\nclass CustomButton: UIButton, Customable {\n    func method() {\n        print("This is customMethod")\n    }\n}\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br")])]),t("h4",{attrs:{id:"协议扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议扩展"}},[s._v("#")]),s._v(" "),t("strong",[s._v("协议扩展")])]),s._v(" "),t("p",[s._v("这个方案"),t("code",[s._v("func method()")]),s._v("还是在"),t("code",[s._v("CustomLabel")]),s._v("和"),t("code",[s._v("CustomButton")]),s._v("中同时实现了，和OOP相比，并没有任何优势。但是Apple在Swift2.0引入为协议引入了一种新的特性，协议扩展，就是可以为协议提供一个默认实现。")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('extension Customable {\n    func method() {\n        print("This is customMethod")\n    }\n}\n')])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("此时"),t("code",[s._v("CustomLabel")]),s._v("和"),t("code",[s._v("CustomButton")]),s._v("只需要遵守这个协议，就可以直接使用"),t("code",[s._v("func method()")]),s._v("这个方法了。")]),s._v(" "),t("p",[s._v("此外，在Swift中Apple的建议是应该更多的使用值类型（结构体类型和枚举类型等），值类型是无法继承的，但是可以引入协议。")]),s._v(" "),t("h4",{attrs:{id:"协议继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议继承"}},[s._v("#")]),s._v(" "),t("strong",[s._v("协议继承")])]),s._v(" "),t("p",[s._v("协议可以从其他协议继承，然后在它继承的需求之上添加功能，因此可以提供更细粒度和更灵活的设计。")]),s._v(" "),t("h4",{attrs:{id:"协议组合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议组合"}},[s._v("#")]),s._v(" "),t("strong",[s._v("协议组合")])]),s._v(" "),t("p",[s._v("类、结构体和枚举可以遵守多个协议，它们可以采用多个协议的默认实现。这在概念上类似于多继承。这种组合的方式不仅比将所有需要的功能压缩到一个基类中更灵活，而且也适用于值类型。")]),s._v(" "),t("p",[s._v("总的来说，面向协议就是通过协议扩展、协议继承和协议组合的方式来设计编写需要的代码。")]),s._v(" "),t("h3",{attrs:{id:"_3-协议的一些注意点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-协议的一些注意点"}},[s._v("#")]),s._v(" 3. 协议的一些注意点")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("Swift协议中的属性：")]),s._v(" "),t("ul",[t("li",[s._v("协议可以定义实例属性和类型属性(使用static)")]),s._v(" "),t("li",[s._v("协议不指定属性是存储属性还是计算型属性，只指定属性名称和类型以及读写性")]),s._v(" "),t("li",[s._v("协议指定属性的读取类型，使用的get和set，中间不能使用逗号")]),s._v(" "),t("li",[s._v("协议总是使用var关键字来声明变量属性")]),s._v(" "),t("li",[s._v("不能给协议属性设置默认值，因为默认值被看做是一种实现")])])]),s._v(" "),t("li",[t("p",[s._v("Swift协议中的方法：")]),s._v(" "),t("ul",[t("li",[s._v("协议可以定义实例方法和类方法(使用static)")]),s._v(" "),t("li",[s._v("协议定义函数时不能添加函数的实现，同时，传入的参数也不能使用默认参数")]),s._v(" "),t("li",[s._v("如果协议定义的实例方法会改变实例本身，需要在定义的方法名前使用mutating；这使得结构和枚举能够遵循此协议并满足此方法要求。")])])]),s._v(" "),t("li",[t("p",[s._v("协议扩展：")]),s._v(" "),t("ul",[t("li",[s._v("添加现有的计算属性和方法，不能添加存储属性")]),s._v(" "),t("li",[s._v("扩展不会增加协议的需求")]),s._v(" "),t("li",[s._v("和泛型一样，协议也能使用where子句进行类型限制")])])]),s._v(" "),t("li",[t("p",[s._v("协议扩展的分发规则")]),s._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("•if 调用方法的变量被推断为协议类型\n    •if 协议中声明了方法\n        无论扩展中是否实现该方法，都调用运行时类型的实现(动态派发)\n    •else\n        直接调用默认实现 (静态派发)\n•else\n    调用该类型的实现\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("p",[t("strong",[s._v("动态派发")]),s._v("是指需要在运行时找到方法的具体实现。   Swift中的动态派发和 OC 中的动态派发类似，在运行时程序会根据被调用的方法的名字去内存中的方法表中查表，找到方法的实现并执行。\n"),t("strong",[s._v("静态派发")]),s._v("是指在运行时调用方法不需要查表，直接跳转到方法的代码中执行。")])])]),s._v(" "),t("p",[t("a",{attrs:{href:"https://onevcat.com/2016/11/pop-cocoa-1/",target:"_blank",rel:"noopener noreferrer"}},[s._v("参考：《面向协议编程与 Cocoa 的邂逅 》"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);